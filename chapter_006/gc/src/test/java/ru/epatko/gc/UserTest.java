package ru.epatko.gc;

import org.junit.Test;

/**
 * @author Mikhail Epatko (mikhail.epatko@gmail.com).
 *         01.03.17.
 */
public class UserTest {

    @Test
    public void whenCreateEmptyObjectsThenCanCalculateUsedMemory() {
        Runtime rt = Runtime.getRuntime();
        for( int i = 0; i < 1000000000; i++) {
            UserWithoutFields user = new UserWithoutFields();
        }
        System.out.println("Used memory after creating objects: " + (rt.totalMemory() - rt.freeMemory()));
    }


    @Test
    public void whenCreateObjectsWithFieldsThenCanCalculateUsedMemory() {
        Runtime rt = Runtime.getRuntime();
        for( int i = 0; i < 12150; i++) {
            User user = new User("q", i);
        }
        System.out.println("Used memory after creating objects: " + (rt.totalMemory() - rt.freeMemory()));
    }

//    6.1.:
//    Чтобы посчитать, сколько места в памяти занимает пустой объект без полей, я несколько раз создал 1 млн.
// таких объектов и посчитал средний арифметический объем использованной памяти. Получилось что-то около 8 Мб.
// Т.е. 1 объект без полей занимает около 8 байт памяти.
//    В книжках пишут, что пустой объект занимает в памяти 8 байт - на 32-разрядных JVM и 16 байт - на 64-разрядных JVM.
//    Т.к. у меня 64-разрядная Java HotSpot, то возможно, что пустой объект у меня занимает 8 байт потому, что используется
// сжатие заголовков.
//    1000 объектов с полями String  и int  у меня заняли памяти порядка 5,5 Мб. что составляет около 5,5 кб на 1 объект.
//    При существенном уменьшении количества доступной JVM памяти сборщик мусора начинает запускаться при создании
// сравнительно небольшого количества объектов с полями (для 20 Мб - чуть более 14000 объектов).
//    При создании слишком большого количества объектов JVM  выдает ошибки:
//      - java.lang.OutOfMemoryError: GC overhead limit exceeded;
//      - Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded.

//    6.2.:
//    С ключом -XX:+UseSerialGC (Serial Collector) при ограничении памяти до 20 Мб сборщик мусора был запущен JVM
// при создании более 12150 объектов с двумя непустыми полями (String  и int).
//    С ключом -XX:+UseParallelGC (Parallel Collector) при ограничении памяти до 20 Мб сборщик мусора был запущен JVM
// при создании более 14090 объектов.
//    С ключом -XX:+UseConcMarkSweepGC (Concurrent Mark-Sweep (CMS) Collector) при ограничении памяти до 20 Мб
// сборщик мусора был запущен JVM при создании более 12150 объектов.
//
//    Serial Collector может быть использован для для большинства приложений, которые работают на стороне клиента
// и которые не предъявляют требования о небольшом времени паузы. На современном оборудовании, серийный коллектор
// может эффективно управлять приложениями с 64 МБ кучи и относительно короткой паузой
// (в худшем случае - менее чем полсекунды для полной коллекции).
//
//    Parallel Collector может быть использован для приложений, которые работают на машинах с более чем одним
// процессором и не имеют ограничений по времени паузы. Примеры приложений, для которых параллельный коллектор
// подходит, - те, которые делают пакетную обработку, выставление счетов, начисление заработной платы,
// научные вычисления и т.п.
//
//    Concurrent Mark-Sweep (CMS) Collector используется в тех случаях, когда приложение нуждается в более коротких
// паузах при сборке мусора и может себе позволить делить ресурсы процессора со сборщиком мусора. Это могут быть
// приложения, которые имеют относительно большой набор долгоживущих данных (большое old generation),
// и работают на машинах с двумя или более процессорами. Например: веб-серверы.
//
// Таким образом, для приложения учета заявок из второго модуля может быть использован Serial Collector.
// Для серверного приложения оптимальным будет выбор Concurrent Mark-Sweep (CMS) Collector.



}